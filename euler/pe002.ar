# https://projecteuler.net/problem=2
#
# Each new term in the Fibonacci sequence is generated by adding the previous
# two terms. By starting with 1 and 2, the first 10 terms will be:
#
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
#
# By considering the terms in the Fibonacci sequence whose values do not
# exceed four million, find the sum of the even-valued terms.
from collections load hash
from system.console load writeln
from string load format

# first we'll define a function to generate a given fibonacci term
# memoized to reduce execution cost
fn[num -> num]:fibonacci = (n){
    # the attach storage qualifier is equivalent to the C static qualifier
    # in this context, the memo variable is attached the the execution block
    # that immediately surrounds it, so that anytime that execution block is
    # entered, memo is restored
    #
    # [LANG]: Note that theres a unique issue here with hash, we need to be
    # able to use it as a type and as a function, I suspect this isn't the
    # last time I'll run into such a use case
    attach hash[num -> opt[num]]:memo = hash(default=None, kv=[(0, 0), (1, 1)])

    opt[num]:result = memo[n]

    if Some(result) {
        unwrap(result)
    } else {
        num:new_value = fibonacci(n - 1) + fibonacci(n - 2)

        # [LANG]: The hash assignment also takes care of our return value
        # here, when assigning to a hash, the assigned value is placed in the
        # return register
        memo[n] = new_value
    }
}

# Yeah, I don't really want this to be the idiomatic solution, but I'm tired
# so I'll come back to it later
#
# [LANG]: There should be a functional (as in FP) way to do this
mut num[i,u,32]:index = 0
mut num[i,u,32]:value = 0
mut num[i,u,32]:sum = 0

repeat {
    if value % 2 == 0 {
        sum += value
    }

    value = fibonacci(index)

    index += 1
} if value <= 4000000

external {
    writeln(sum)
}
